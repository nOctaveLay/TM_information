# 일급 함수
- 파이썬의 함수는 일급 객체다.
	- 일급 객체 : first-class object, 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체.
		일급 객체로 정의하는 경우
		- 런타임(runtime)에 생성할 수 있다.
		- 데이터 구조체의 변수나 요소에 할당할 수 있다.
		- 함수 인수로 전달할 수 있다.
		- 함수 결과로 반환할 수 있다.
	- 정수, 문자열, 딕셔너리도 파이썬의 일급 객체다.

## 함수를 객체처럼 다루기
- 함수를 변수에 할당하고, 변수명을 통해 함수를 호출할 수 있다.
- 함수를 인수로 전달할 수 있다. (ex, map(함수,iterable한 객체))
- 일급 함수가 있으면 함수형 스타일로 프로그래밍 할 수 있다. 

## 고위함수
- 함수를 인수로 받거나, 함수를 결과로 반호나하는 함수
- ex) map(), sorted() (sorted()의 경우, key 인수로 인수를 하나 받는 함수를 전달받는다.)
- map(), filter(), reduce(), apply() 등의 고위 함수가 알려져 있다.
	- apply()는 더 이상 필요하지 않아서 제거되었다.
	- apply(fn,args,kwargs) 대신 fn(\*args,\*\*keywords) 형태로 작성한다.
	- 나머지 세 함수의 경우, 더 나은 다른 방법이 존재한다.

### map(),filter(),reduce()의 대안
- map()과 filter()는 파이썬 3에 내장되어 있지만, 지능형 리스트와 제너레이터 표현식이 소개된 이후 중요성이 떨어졌다.
- 지능형 리스트 & 제너레이터가 가독성이 훨씬 좋다.

**Example**
```python3
list(map(fact,range(6))) #1
[fact(n) for n in range(6)] #2

list(map(factorial, filter(lambda n : n%2, range(6)))) #3
[factorial(n) for n in range(6) if n %2]#4
```
\#1 - 0! ~ 5!까지의 팩토리얼 리스트를 만든다.
\#2 - #1과 동일한 작업, 지능형 리스트 사용
\#3 - map과 filter를 사용해서 5!까지 홀수에 대한 팩토리얼 리스트를 만든다.
\#4 - lamda없이 지능형 리스트로 동일한 작업 수행

- 파이썬 3에서, map()과 filter()는 제너레이터 (반복 가능한 객체)를 반환하므로, 제너레이터 표현식이 이를 직접 대체한다.
- 파이썬 2에 내장되었던 reduce() 함수는 파이썬 3에서는 functools 모듈로 떨어져 나왔다.
- reduce() 함수보다는 sum이 가독성과 성능 면에서 훨씬 낫다. (따로 함수를 임포트하거나 추가할 필요가 없다.)
- sum()과 reduce()는 이전 결과를 누적시키면서 하나의 값으로 reduction하는 함수이다.
- 다른 reduction 함수 : all, any
	- all (iterable)
		모든 iterable이 참이면 True를 반환
	- any (iterable)
		iterable 중 하나만 참이면 True를 반환
- 고위 함수를 사용할 때 작은 일회성 함수를 생성하는 게 편리하기도 하다. (이를 익명함수라고 부른다.)

## 익명 함수
- lamda 키워드는 파이썬 표현식에 익명 함수를 생성한다.
- lamda 함수의 본체는 순수한 표현식으로만 구성되도록 제한 받는다.
	다시 말하자면, 람다 본체에서는 할당문이나 while, try등의 파이썬 문장을 활용할 수 없다.
- 고위 함수의 인수로 사용하는 방법 외에 익명 함수는 파이썬에서 거의 사용되지 않는다.
- def문과 마찬가지로, 람다 표현식도 함수 객체를 만든다. 
- 즉, 여러 콜러블 객체 중 하나일 뿐이다.

**런드의 람다 리팩토링 비법** 
<http://docs.python.org/3/howto/functional.html>
1. 람다가 하는 일이 무엇인지 설명하는 주석을 작성한다.
2. 주석을 주의 깊게 파악 -> 본질을 전달하는 이름을 생각한다.
3. 람다를 def 문으로 변경한다.
4. 주석을 제거한다.

## 콜러블 객체
- 호출할 수 있는 객체인지 알아보려면 callable() 내장 함수를 사용한다.
- 일곱 가지 콜라블 (파이썬 데이터 모델 문서에 나열)
	- 사용자 정의 함수 (def, 람다 표현식)
	- 내장함수 (len(), time.strftime()처럼 C언어로 구현된 함수, if CPython)
	- 내장 메서드 (dict.get()처럼 C언어로 구현된 메서드)
	- 메서드 (클래스 본체에 정의된 함수)
	- 클래스
		- \_\_new\_\_() 로 객체 생성
		- \_\_init\_\_() 으로 초기화
		- 호출자에 대한 객체 반환
		- 파이썬에는 new연산자가 없으므로, 클래스 호출 == 함수 호출.
	- 클래스의 객체 (\_\_call\_\_() 메서드를 구현했을 경우)
	- 제너레이터 함수(yield 키워드를 사용하는 함수나 메서드)
		- 제너레이터 함수는 다른 콜러블과 다르다.
		- 제너레이터 함수는 코루틴으로 사용될 수도 있다.

## 사용자 정의 콜러블형
- 모든 파이썬 객체가 함수처럼 동작하게 만들 수 있다. (\_\_call\_\_() 인스턴스 메서드 구현할 시)
- 객체를 함수처럼 호출할 때마다 변경된 상태를 유지해야 하는데, \_\_call\_\_() 메서드를 구현하면 이런 객체를 생성하기 쉽다.
	ex) 
		- 데커레이터
			- 데커레이터는 함수지만, 호출된 후의 상태를 '기억' 할 수 있는 기능이 유용하게 사용된다.
		- 클로저
			- 내부 상태를 가진 함수를 전혀 다른 방식으로 생성한다.

## 함수 인트로스펙션
- 함수를 객체로 다루는 방식
- 일반적인 사용자 정의 클래스의 객체와 마찬가지로, 함수는 \_\_dict\_\_ 속성을 이용해서 객체에 할당된 사용자 속성을 보관한다.
- 이 속성은 기본적인 애너테이션 형태로 쓸모가 많다.
- 프레임워크 (장고 등)은 이 기능을 사용한다.

## 위치 매개변수, 키워드 전용 매개변수
* positional argument, keyword-only argument. 
- 키워드 전용 인수를 이용해서 향상된 매개 변수 메커니즘은 파이썬 함수에서 볼 수 있는 가장 훌륭한 기능
- 반복 가능 객체나 매핑형을 별도의 인수로 폭발시키는 \*와 \*\*기호도 이 메커니즘과 밀접하게 연관되어 있다.
- 함수를 정의할 때 키워드 전용 인수를 지정하려면 \*가 붙은 인수 뒤에 이름을 지정한다.
- 가변 개수의 위치 인수를 지원하지 않으면서 키워드 전용 인수를 지원하고 싶으면, \*만 시그니처에 포함시키면 된다.
- 키워드 전용 인수는 기본값을 지정하지 않아도 되며, 필수 인수로 만들 수도 있다.

+ 위치 인수 : 함수에서, 일반적인 인자 (\*<변수>로, 위치 인수를 여러개 지정하거나 언패킹 가능하다.)
+ 키워드 인수 : 함수에서, a = ''로 지칭하는 인자(\*\*<변수>로, 키워드 인수를 여러개 지정하거나 언패킹 가능하다.)

## 매개변수에 대한 정보 읽기
- 함수에 어떤 매개변수가 필요한지, 매개변수에 기본값이 있는지 없는지 알 수 있는 방법
	- 함수 객체 안의 \_\_defaults\_\_ 속성에는 위치(positional)인수와 키워드(keyword)인수의 기본값을 가진 튜플이 들어있다.
	- 키보드 전용 인수의 기본값은 \_\_kwdefaults\_\_속성에 들어 있다.
	- 그러나 인수명은 \_\_code\_\_ 속성에 들어있다. 
		* 이 속성은 여러 속성을 담고 있는 code 객체를 가리킨다.
		* 인수명은 \_\_code\_\_.co_varnames에 들어가 있다. (함수 본체에서 생성한 지역 변수명도 들어있다.)
		* \_\_code\_\_.co_argcount가 인수명이다. \*나 \*\*가 붙은 인수명은 포함하지 않는다.
	- 인수의 기본값을 \_\_default\_\_와 대조시킬시, 처리 과정은 ....
	- 이는 inspect 모듈을 사용하면 깔끔하게 처리가 가능하다
		- inspect.signature()는 inspect.Signature 객체를 반환한다.
		- 이 객체에 들어있는 parameters 속성을 이용하면 정렬된 inspect.Parameter 객체를 읽을 수 있다.
		- 각 Parameter 객체 안에는 name, default,kind 등의 속성이 들어 있다.
		- inspect.\_empty라는 특별한 값은 매개변수에 기본값이 없음을 나타낸다.
		- kind 속성은 \_ParameterKind 클래스에 정의된 다섯 가지 값 중 하나를 나타낸다.
			* POSITIONAL_OR_KEYWORD : 위치 인수나 키워드 인수로 전달할 수 있는 매개변수
			* VAR_POSITIONAL : 위치 매개변수의 튜플
			* VAR_KEYWORD : 키워드 매개변수의 튜플
			* KEYWORD_ONLY : 키워드 전용 매개변수(파이썬 3)
			* POSITIONAL_ONLY : 위치 전용 매개변수. (키워드로 전달한 매개변수를 받지 않는 C언어로 구현된 기존 함수. 파이썬 함수 선언 구문에서는 지원 X)
		- annotation : 시그니처 메타데이터가 들어갈 수 있다. 일반적으로는 inspect.\_empty
		- inspect.Signature 객체에는 bind() 메서드가 정의되어 있다.
			- bind() : 임의 개수의 인자를 받고, 인수를 매개변수에 대응시키는 일반적인 규칙을 적용해서 그것을 시그너처에 들어있는 매개변수에 바인딩
			- 프레임워크에서 실제 함수를 호출하기 전에 인수를 검증하기 위해 사용할 수 있다. (매개변수가 빠져있을시, 에러를 발생시킨다.)
			
# 함수 애너테이션(말 뭉치 주석)
- 파이썬 3는 함수의 매개변수와 반환값에 메타데이터를 추가할 수 있는 구문을 제공한다.
- 함수 선언에서, 각 매개변수에는 콜론 뒤에 애너테이션 표현식을 추가할 수 있다.
ex) def clip(test:str,max_len:'int>0' = 80) ->str:

- 애너테이션은 인수와 등호 사이에 들어간다.
- 반환값에 애너테이션을 추가하려면 매개변수를 닫는 괄호와 함수 선언의 제일 뒤에 오는 콜론 사이에 -> 기호와 표현식을 추가한다. (-> int라고 쓰면, return : \< class 'int'\>로 반영된다.)
- 애너테이션은 전혀 처리되지 않으며, 함수 객체 안의 dict 형 \_\_annotations\_\_ 속성에 저장될 뿐이다.
	- 애너테이션은 도구, 프레임워크, 데커레이터가 사용할 수 있는 메타데이터일 뿐이다.
	- inspect.signature()는 애너테이션을 추출하는 방법을 알고 있다.
	- 함수 애너테이션은 정적 자료형 검사를 지원하기 위해 선택적인 자료형 정보를 제공하는데 큰 영향을 준다.

# 함수형 프로그래밍을 위한 패키지

## operator 모듈
- 사소한 익명 함수를 작성하는 수고를 덜기 위해, 수십 개의 연산자에 대응하는 함수를 제공.
- 모든 시퀀스에서 항목을 가져오는 람다를 대체하는 itemgetter() 함수와 객체의 속성을 읽는 람다를 대체하는 attrgetter() 함수를 제공.
- itemgetter(x)
	- lamda fields : fields[1] 과 동일
	- 여러개의 인덱스를 인수로 전달하면, 생성된 함수는 해당 인덱스의 값들로 구성된 튜플을 반환
	- []연산자를 사용하므로, 시퀀스 뿐만 아니라 매핑 및 \_\_getitem\_\_()을 구현한 모든 클래스를 지원.
- attrgetter()
	- 이름으로 객체 속성을 추출.
	- 여러 속성명을 인수로 전달하면, 해당 속성값으로 구성된 튜플 반환.
	- 점(.)이 포함되어 있으면 내포된 객체를 찾아서 해당 속성을 가져옴.
- methodcaller()가 생성한 함수는 인수로 전달받은 객체의 메서드를 호출한다.
	- functools.partial() 함수처럼 일부 인수를 고정할 수 있다.

## functools.partial()로 인수 고정하기
- 함수를 부분적으로 실행할 수 있게 해주는 고위 함수.
- 원래 함수의 일부 인수를 고정한 콜러블을 생성한다.
- 하나 이상의 인수를 받는 함수를 그보다 적은 인수를 받는 콜백 함수를 사용하는 API에 사용하고자 할 때 유용
- functools.partialmethod() 함수는 partial() 과 동일하지만 메서드에 대해 작동하도록 설계
- lru_cache() : 메모이제이션을 수행하는 함수
	- 메모이제이션? 값비싼 연산을 다시 수행하지 않도록 함수 호출 결과를 저장하는 자동 최적화 기법

# 추가 내용
## 함수 애너테이션을 어디에 쓰면 좋나요?
- documentation
- pre-condition checking (만족하지 못했을 시, AssertionError가 뜸)


출처 : Fluent python (O'RELLY 한빛미디어), 5장 일급함수 [pg 197-226]
<https://stackoverflow.com/questions/3038033/what-are-good-uses-for-python3s-function-annotations>
<https://stackoverflow.com/questions/13784713/what-good-are-python-function-annotations>