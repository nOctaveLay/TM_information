# 일급 함수
- 파이썬의 함수는 일급 객체다.
	- 일급 객체 : first-class object, 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체.
		일급 객체로 정의하는 경우
		- 런타임(runtime)에 생성할 수 있다.
		- 데이터 구조체의 변수나 요소에 할당할 수 있다.
		- 함수 인수로 전달할 수 있다.
		- 함수 결과로 반환할 수 있다.
	- 정수, 문자열, 딕셔너리도 파이썬의 일급 객체다.

## 함수를 객체처럼 다루기
- 함수를 변수에 할당하고, 변수명을 통해 함수를 호출할 수 있다.
- 함수를 인수로 전달할 수 있다. (ex, map(함수,iterable한 객체))
- 일급 함수가 있으면 함수형 스타일로 프로그래밍 할 수 있다. 

## 고위함수
- 함수를 인수로 받거나, 함수를 결과로 반호나하는 함수
- ex) map(), sorted() (sorted()의 경우, key 인수로 인수를 하나 받는 함수를 전달받는다.)
- map(), filter(), reduce(), apply() 등의 고위 함수가 알려져 있다.
	- apply()는 더 이상 필요하지 않아서 제거되었다.
	- apply(fn,args,kwargs) 대신 fn(\*args,\*\*keywords) 형태로 작성한다.
	- 나머지 세 함수의 경우, 더 나은 다른 방법이 존재한다.

### map(),filter(),reduce()의 대안
- map()과 filter()는 파이썬 3에 내장되어 있지만, 지능형 리스트와 제너레이터 표현식이 소개된 이후 중요성이 떨어졌다.
- 지능형 리스트 & 제너레이터가 가독성이 훨씬 좋다.

**Example**
```python3
list(map(fact,range(6))) #1
[fact(n) for n in range(6)] #2

list(map(factorial, filter(lambda n : n%2, range(6)))) #3
[factorial(n) for n in range(6) if n %2]#4
```
\#1 - 0! ~ 5!까지의 팩토리얼 리스트를 만든다.
\#2 - #1과 동일한 작업, 지능형 리스트 사용
\#3 - map과 filter를 사용해서 5!까지 홀수에 대한 팩토리얼 리스트를 만든다.
\#4 - lamda없이 지능형 리스트로 동일한 작업 수행

- 파이썬 3에서, map()과 filter()는 제너레이터 (반복 가능한 객체)를 반환하므로, 제너레이터 표현식이 이를 직접 대체한다.
- 파이썬 2에 내장되었던 reduce() 함수는 파이썬 3에서는 functools 모듈로 떨어져 나왔다.
- reduce() 함수보다는 sum이 가독성과 성능 면에서 훨씬 낫다. (따로 함수를 임포트하거나 추가할 필요가 없다.)
- sum()과 reduce()는 이전 결과를 누적시키면서 하나의 값으로 reduction하는 함수이다.
- 다른 reduction 함수 : all, any
	- all (iterable)
		모든 iterable이 참이면 True를 반환
	- any (iterable)
		iterable 중 하나만 참이면 True를 반환
- 고위 함수를 사용할 때 작은 일회성 함수를 생성하는 게 편리하기도 하다. (이를 익명함수라고 부른다.)

## 익명 함수
- lamda 키워드는 파이썬 표현식에 익명 함수를 생성한다.
- lamda 함수의 본체는 순수한 표현식으로만 구성되도록 제한 받는다.
	다시 말하자면, 람다 본체에서는 할당문이나 while, try등의 파이썬 문장을 활용할 수 없다.
- 고위 함수의 인수로 사용하는 방법 외에 익명 함수는 파이썬에서 거의 사용되지 않는다.
- def문과 마찬가지로, 람다 표현식도 함수 객체를 만든다. 
- 즉, 여러 콜러블 객체 중 하나일 뿐이다.

**런드의 람다 리팩토링 비법** 
<http://docs.python.org/3/howto/functional.html>
1. 람다가 하는 일이 무엇인지 설명하는 주석을 작성한다.
2. 주석을 주의 깊게 파악 -> 본질을 전달하는 이름을 생각한다.
3. 람다를 def 문으로 변경한다.
4. 주석을 제거한다.

## 콜러블 객체
- 호출할 수 있는 객체인지 알아보려면 callable() 내장 함수를 사용한다.
- 일곱 가지 콜라블 (파이썬 데이터 모델 문서에 나열)
	- 사용자 정의 함수 (def, 람다 표현식)
	- 내장함수 (len(), time.strftime()처럼 C언어로 구현된 함수, if CPython)
	- 내장 메서드 (dict.get()처럼 C언어로 구현된 메서드)
	- 메서드 (클래스 본체에 정의된 함수)
	- 클래스
		- \_\_new\_\_() 로 객체 생성
		- \_\_init\_\_() 으로 초기화
		- 호출자에 대한 객체 반환
		- 파이썬에는 new연산자가 없으므로, 클래스 호출 == 함수 호출.
	- 클래스의 객체 (\_\_call\_\_() 메서드를 구현했을 경우)
	- 제너레이터 함수(yield 키워드를 사용하는 함수나 메서드)
		- 제너레이터 함수는 다른 콜러블과 다르다.
		- 제너레이터 함수는 코루틴으로 사용될 수도 있다.

## 사용자 정의 콜러블형
- 모든 파이썬 객체가 함수처럼 동작하게 만들 수 있다. (\_\_call\_\_() 인스턴스 메서드 구현할 시)
- 객체를 함수처럼 호출할 때마다 변경된 상태를 유지해야 하는데, \_\_call\_\_() 메서드를 구현하면 이런 객체를 생성하기 쉽다.
	ex) 
		- 데커레이터
			- 데커레이터는 함수지만, 호출된 후의 상태를 '기억' 할 수 있는 기능이 유용하게 사용된다.
		- 클로저
			- 내부 상태를 가진 함수를 전혀 다른 방식으로 생성한다.

## 함수 인트로스펙션
- 함수를 객체로 다루는 방식
- 일반적인 사용자 정의 클래스의 객체와 마찬가지로, 함수는 \_\_dict\_\_ 속성을 이용해서 객체에 할당된 사용자 속성을 보관한다.
- 이 속성은 기본적인 애너테이션 형태로 쓸모가 많다.
- 프레임워크 (장고 등)은 이 기능을 사용한다.

## 위치 매개변수, 키워드 전용 매개변수
- 키워드 전용 인수를 이용해서 향상된 매개 변수 메커니즘은 파이썬 함수에서 볼 수 있는 가장 훌륭한 기능
- 반복 가능 객체나 매핑형을 변도의 인수로 폭발시키는 \*와 \*\*기호도 이 메커니즘과 밀접하게 연관되어 있다.
- 함수를 정의할 때 키워드 전용 인수를 지정하려면 \*가 붙은 인수 뒤에 이름을 지정한다.
- 가변 개수의 위치 인수를 지원하지 않으면서 키워드 전용 인수를 지원하고 싶으면, \*만 시그니처에 포함시키면 된다.

## 매개변수에 대한 정보 읽기


출처 : Fluent python (O'RELLY 한빛미디어), 5장 일급함수 [pg 197-]