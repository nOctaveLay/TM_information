# 일급 함수의 디자인 패턴
- 패턴에 참여하는 일부 클래스의 객체를 간단한 함수로 교체하면, 획일적으로 반복되는 코드의 상당 부분을 줄일 수 있다.

## 고전적인 전략

- UML 클래스 다이어그램
	- 구성요소
		- 콘테스트 : 일부 계산을 서로 다른 알고리즘을 구현하는, 교환 가능한 컴포넌트에 위임함으로써 서비스를 제공
		- 전략 : 여러 알고리즘을 구현하는 컴포넌트에 공통된 인터페이스.
		- 구체적인 전략 : 전략의 구상 서브클래스 중 하나
- 전략 패턴 : **일련의 알고리즘을 정의하고 각각을 하나의 클래스 안에 넣어서 교체하기 쉽게 만든다. 전략을 이용하면 사용하는 클라이언트에 따라 알고리즘을 독립적으로 변경할 수 있다.**
- EX : 전자 상거래 영역

## 함수지향 전략
- 전략 객체가 상태(객체 속성)을 가지고 있지 않기 때문에, 이를 바꿔준다. -> 전략을 class가 아닌, 함수로 교체
- 새로운 콘테스트에서 동일 전략 객체를 반복해서 적용할 때에는 새로 생성하는 비용을 줄이기 위해 플라이웨이트를 공유하는 것이 좋다.
	- 플라이 웨이트 : 여러 콘테스트에서 동시에 사용할 수 있는 공유 객체
	- 런타임 비용을 줄이기 위해 권고되었음
	- 유지보수비용 & 소스코드 행수가 늘어남
- 구체적인 전략 객체가 내부 상태를 가지고 있어서 복잡한 경우에는 모든 전략 패턴과 플라이웨이트 패턴을 혼합해서 사용
- 구체적인 전략 객체가 내부 상태 X고 데이터만 처리할 경우 -> 일반 함수가 훨씬 좋음 (플라이 웨이트가 필요 X)

## 모듈에서 전략찾기
- globals()
	- 현재 전역 심벌 테이블을 나타내는 딕셔너리 객체를 반환한다.
	- 이 딕셔너리는 언제나 현재 모듈에 대한 내용을 담고 있다.
	- 함수나 메서드 안에서 호출할때, 함수를 호출한 모듈이 아니라 함수가 정의된 모듈을 나타낸다.
	- ex)
		promos = [globals()[name] for name in globals() 
					if name.endwith('\_promo')
					and name != 'best_promo']
- 별도의 모듈을 만들고 모든 프로모션 할인 함수를 모듈에 넣어서 적용할 수 있는 모든 함수를 모으는 방법도 있다.
	-ex)
		- promos = [func for name, func in 
					inspect.getmembers(promotions, inspect.isfunction)]
		- inspect.getmembers() 함수는 조건식으로 걸러낸 객체의 속성들을 반환한다.
		- 함수명에 상관없이 작동한다. (다른 시그니처를 가진 함수를 추가하면, 오류를 발생시킨다.)
		- 객체의 인수를 조사함으로써 함수를 걸러내기 위해 엄격하게 테스트할 수도 있다.
		- 함수를 동적으로 수집할 때, 간단한 데커레이터를 사용하면 더욱 명시적으로 처리할 수 있다.

# 명령
- 함수를 인수로 전달하는 기법을 사용하면 명령 디자인 패턴도 구현을 단순하게 만들 수 있다.
- 명령 패턴의 목적은 연산을 실행하는 객체(호출자)와 연산을 구현하는 객체(수신자)를 분리하는 것이다.
- 기본 개념은 명령 객체를 수신자와 호출자 사이에 놓고, 명령은 execute()라는 단 하나의 메서드로 인터페이스를 구현한다.
	- execute()는 원하는 연산을 수행하기 위해 수신자가 가지고 있는 메서드를 호출한다.
	- 호출자는 수신자의 인터페이스를 알 필요가 없으며, 명령의 서브클래스를 통해 서로 다른 수신자를 추가할 수 있다.
	- 호출자는 구체적인 명령으로 설정되며, 연산을 실행하기 위해 execute() 메서드를 호출한다.
- 디자인 패턴에서, "명령은 콜백에 대한 객체 지향식 대체물"
	- 콜백을 객체지향식 대체물로 바꿀 필요? 늘 그런 것은 아니다.
	- 고급 기능의 명령 패턴을 구현하려고 할 때
		- 콜러블 객체는 필요한 상태를 보관함으로서 \_\_call\_\_() 메서드 이외의 메서드도 제공할 수 있다.
		- 함수가 호출된 후의 상태를 내부에 보관하기 위해 클로저를 사용할 수 있다.
	- 단일 메서드 인터페이스를 구현하는 객체를 콜러블로 대체. (모든 파이썬 콜라블이 \_\_call\_\_()이라는 단일 메서드 인터페이스를 구현하므로, 이런 대안이 가능)

# 요약
- 파이썬은 리스프와 Dylan 언어의 동적 특성 일부를 공유한다.
- 파이썬에서 함수나 콜러블 객체를 이용해서 더욱 자연스럽게 콜백을 구현하는 것이 가능하다.

