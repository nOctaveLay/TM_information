# 1966번

### 처음에 생각했던 것.
1. 우선순위가 높은 것부터 지우자 (체를 이용하듯)
2. cycle을 이용해서 우선순위가 높은 애가 다 지워졌는지 확인하자.
3. 다 지워졌으면 처음으로 돌아가서 우선순위를 1 낮추고 다시 진행하자.

**결과 : 실패**
이유 : 아예 잘못된 방식으로 품 -> 문제를 꼼꼼히 읽자 
* 이 방식대로 하면 마지막 Case 1 1 9 1 1 1을 풀 수가 없다.

### 두 번째에 생각했던 것
1. 마지막 case를 보니 자기 차례에서 우선순위를 확인하고, 자기보다 높은게 없으면 꺼내는 방식이다.
2. 자기보다 높은 건 어떻게 알아내지? max를 이용해서 자기가 max인지 확인한다. 
3. (C에서는 자신의 위치에서 elem(list 원소)만큼 확인해야하지만, python에서는 max라는 함수가 존재한다.)
4. 처음에는 queue에서 get을 한 즉시 find를 바꿔버려서, find가 애초에 0일때 작동이 안되는 문제가 있었다. find == 0인지 미리 확인하고 나중에 감소하는 방식으로 바꿨다.

**결과 : 성공**

#### 추가적으로 실수했던 것
1. map()은 iterator를 반환하기 때문에, list로 사용하고 싶으면 list()함수를 써야 했다. 그런데 그냥 map()을 하니, max()에서 argument가 없다고 에러를 띄웠다.
2. 당연하지만 max()는 argument를 최소 2개까지 받는데, 하나 받을 때에도 그냥 그 자신을 return하는 줄 알았다. max()는 2개 이상의 argument를 받는다는 것을 기억해야겠다.