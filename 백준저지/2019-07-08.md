# 17298

### 처음에 이 문제를 풀 때 생각했던 것

1. 입력을 받아 리스트를 만들고, x번째를 가리키는 index를 사용하자.
2. x번째부터 시작해서, 자기보다 큰 수가 있으면 break시켜서 바로 빠져나오게 하자.
3. 자기보다 큰 수가 없으면 -1을 출력하니까, 입력 리스트의 말미에 -1을 넣어 출력을 쉽게 만들자
4. for문으로 추적하는 index를 초기화 시키자.

**결과: time out**

이유 -> 1초 안에 수행되어야 하는데, 이렇게 할 경우 O(n^2)의 시간이 걸린다.

### 두 번째에 이 문제를 풀 때 생각했던 것
**입력 받을 때마다 판단하자**

어떻게 판단할까? 
1. 결과 리스트에다가 결과를 저장하자.
2. stack에 아직 처리되지 않는 애들을 저장해두자
	* 어떻게 처리할까? 
		* 원소를 stack에 넣어 입력 받는 애(elem)과 비교하는 방법과
		* 원소를 저장하는 index를 스택에 집어넣어 결과 리스트에 빠르게 반영하는 방법
	* 속도가 중요하기 때문에 2번 방법으로 했다.
3. 스택 list에 있는 index를 꺼내서 elem보다 작을 경우 result list에 elem을 저장한다.
4. 결과를 출력한다.

**결과 : time out**

이유 -> 만약 1 20 11 10 9 6 8이 있다면 8이 입력되었을 때 6은 처리가 되어야 하지만 9 이전은 1은 이미 20으로 처리되었고, 20 11 10은 9보다 큰 수이므로 처리하지 않아도 되는데, 두 번째 풀때의 3번의 방식대로 하면 이 경우들도 모두 계산하고 있어서 시간이 낭비가 된다.

### 세 번째에 이 문제를 풀 때 2번째에서 추가한 것
**불필요한 부분을 끊어주자**

* 어차피 작을 경우에는 무조건 result list에 elem을 저장하고, 이는 자신보다 크거나 같은 수가 나타나기 전까지는 숫자가 무엇이든 다 elem으로 바꿔줘야 하므로, (10 8 6 9 에서 8 6 은 무조건 9로 바꿔야 한다.) 저장된 수들을 찾다가 elem보다 크거나 같으면 break 시켜줘야 한다.  

**결과 : 맞음**

### 결론
1. 좀 더 효율적으로 짤 수 있는 방안을 모색해보자
2. 이걸 다시 클린하게 짜보자.
