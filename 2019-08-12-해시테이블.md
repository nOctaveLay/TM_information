#딕셔너리 안의 해시테이블 (with python3)

1. 해시 테이블은 희소배열(중간에 빈 항목을 가진 배열)이다.
2. 해시 테이블 안에 있는 항목을 종종 '버킷'이라고 부른다.
3. 해시 테이블에는 각 항목별로 버킷이 있다.
4. 버킷에는 키에 대한 참조와 항목의 값에 대한 참조가 들어간다.
5. 모든 버킷의 크기가 동일하므로, 오프셋을 계산해서 각 버킷에 바로 접근할 수 있다.

* 파이썬은 버킷의 1/3이상을 비워두려고 노력한다.
* 해시 테이블 항목이 많아지면 더 넓은 공간에 복사해서 버킷 공간을 확보한다.
* 해시 테이블 안에 항목을 넣을 때:
	* 항목 키의 해시값을 계산한다. (with hash())

### 해시와 동치성

* hash() - 내장 자료형은 **직접** 사용자 정의 자료형일 경우 **\_\_hash\_\_()** 메서드 호출.
* 객체가 동일하면 해시값도 동일해야 한다.
* 정수 1과 실수 1의 내부 표현형태는 다르지만, 1 == 1.0이 참이므로 hash(1) == hash(1.0)

* 해시 테이블 인덱스처럼 효율성을 높이려면 해시값이 가능한 한 인덱스 공간에 골고루 퍼져야 한다.
	* 동일하지 않은 객체들의 해시값은 상당히 달라야한다.

* tip: 파이썬 3.3부터 str,bytes,datetime 객체의 해시에는 **무작위 솔트값**이 추가된다.
	* 무작위 솔트값 : DOS공격을 피하기 위한 보안 장치
	* 솔트값은 파이썬 프로세스가 실행되는 동안에는 동일하게 유지되지만, 파이썬 프로세스를 새로 실행하면 달라진다.

### 해시 테이블 알고리즘
1. 해시값을 가져온다.
2. 해시값의 최하위 비트를 해시 테이블 안의 버킷에 대한 오프셋으로 사용한다.
	(사용하는 비트 수는 현재 테이블 크기에 따라 달라진다.)
3. 
	- 찾아낸 버킷이 비어있으면 -> KeyError
	- 그렇지 않으면 -> 버킷에 들어있는 항목인 (found_key:found_value)쌍을 검사해서
		search_key == found_key인지 검사한다.
		일치할 경우, 항목을 찾은 것이므로 found_value를 반환한다.

**해시충돌** : search_key와 found_key가 다를 경우.
	- 해시 함수가 임의의 객체를 적은 수의 비트로 매핑하기 때문에 발생.
	- 해결하기 위해서, 해시의 다른 비트들을 가져와서 특정한 방식으로 조작한 후, 그 결과를 이용해서 다른 버킷을 조회한다.
		- 비어있을 경우 : KeyError
		- 일치할 경우 : 항목 값 반환
		- 일치하지 않을 경우 : 충돌 해결 프로세스 반복

**해시 테이블이 커지면 더 많은 해시비트를 버킷 오프셋으로 사용하고, 더 많은 비트를 사용할 수록 충돌률은 낮아진다.**

# dict 작동 방식에 의한 영향

### 키 객체는 반드시 해시 가능해야 한다.

#### 해시 가능하다?
1. 객체의 수명주기 동안 언제나 동일한 값을 반환하는 \_\_hash\_\_() 메서드를 제공해서 hash() 함수를 지원한다.
2. \_\_eq\_\_() 메서드를 통해 동치성을 판단할 수 있다.
3. a == b가 참이면, hash(a) == hash(b) 도 참이어야 한다.

사용자 정의 자료형은, id()를 해시값으로 사용하고, 모든 객체는 서로 동일하지 않으므로 기본적으로 해시 가능하다.

**\_\_eq\_\_()**를 구현할 때는 \_\_hash\_\_도 적절하게 구현해야 해시 가능하다.
이는 3.에 의거한다. 그렇지 않으면 헤시 테이블 알고리즘의 기본 규칙을 어기게되어, dict()나 set()이 객체를 제대로 처리할 수 없게 된다.
**\_\_eq\_\_()**가 가변 상태에 기반하는 경우, \_\_hash\_\_는 TypeError를 발생시켜야 한다.

### dict의 메모리 오버헤드가 크다.
1. dict는 내부적으로 해시 테이블을 사용하고 있다.
2. python3에서 해시 테이블을 사용할 때는 항상 버킷의 1/3 이상을 비워두려고 하고, 비우지 못할 경우 공간을 확장시킨다.
3. 즉, 빈 공간이 충분해야 해시가 제대로 작동한다.
4. 하지만 이 빈 공간은 아무것도 쓰지 않으므로 오버헤드가 크다고 말할 수 있다.

*즉,* 많은 양의 레코드를 처리하는 경우 딕셔너리의 리스트를 사용하는 것보다, **튜플이나 명명된 튜플의 리스트에 저장하는 것이 좋다.**
	- 이럴 경우, 레코드마다 하나의 해시 테이블을 가져야 하는 부담을 줄일 수 있다.
	- 레코드마다 필드명을 다시 저장해야 하는 부분을 제거한다.
	- 메모리 사용량을 줄일 수 있다.

**사용자 정의형의 경우**
1 \_\_slot\_\_ 클래스 속성을 이용해서 객체 속성 저장소를 dict에서 튜플로 변경할 수 있다.

### 키 검색이 아주 빠르다.

* dict는 속도를 위해 공간을 포기한다.
* dict의 크기를 1000에서 10,000,000 요소로 증가시켰을 때, 검색 시간은 고작 2.8배 증가한다.
(즉, dict에서 키 이백만개를 검색하는 데 1초도 걸리지 않는다.)

### 키 순서는 삽입 순서에 따라 달라진다.

* 해시 충돌이 발생하면 두 번째 키는 충돌이 발생하지 않았을 때의 정상적인 위치와 다른 곳에 놓이게 된다.
* dict([(key1,value1),(key2,value2)])로 생성한 딕셔너리와 dict([(key2,value2),(key1,value1)])으로 생성한 딕셔너리는 동일하다.
* 하지만 key1과 key2의 해시가 충돌하면 키의 순서는 달라진다.

### 딕셔너리에 항목을 추가하면 기존 키의 순서가 변경될 수 있다.

* 파이썬 인터프리터가 해시 테이블의 크기를 늘릴때, 큰 해시테이블을 새로 만들어서 기존 항목을 새 테이블에 추가하는 방식을 쓴다.
* 이 때, 기존의 추가방식과 다르게 해서 해시 충돌이 발생할 수 있으며, 그 때 키 순서가 달라질 수 있다.
* 이 현상은 구현 알고리즘에 따라 달라지기 때문에, 예측 불가능하다.
* 딕셔너리 키를 반복하는 도중에 항목을 변경하는 경우, 원하는 대로 항목을 검색하지 못하는 경우가 발생할 수 있다. (변경되지 않은 것도 제대로 검색 불가능할 수 있다.)

**항목을 추가해야 하는 경우**
	1. 처음부터 끝까지 딕셔너리를 검색하면서, 필요한 항목은 별도의 딕셔너리에 추가
	2. 별도의 딕셔너리로 원래의 딕셔너리 생산

**python3에서 keys(),items(), values() 메서드가 반환하는 딕셔너리 뷰는 일종의 집합처럼 동작한다. 이 뷰는 딕셔너리의 내용을 복제하지 않고 동적으로 갱신되므로, dict의 변경사항을 즉시 반영한다.**